.data
    newline dq 10
    sys_write equ 33554436
   ; 33554436
    sys_mmap equ 33554629
   ; 33554629

.code

; ENCODE

encode proc
    mov r15, [rsp + 8]
    push r15

    call count
    call sort
    call tree
    call generate

    ; Print 
    push rcx
    push rax
    call print
    add rsp, 16

    call print_line

    add rsp, 8
    ret

encode endp

; `count` takes in a c string parameter from the stack and records the frequency of each unique characters in the string.
; It returns the memory address of the structured data consisting of the characters along with their frequencies in the rax register.
; The memory layout for this return structure will be:
;
; struct {
;     int uniqueCharactersCount; // 4 bytes
;     struct {
;         bool isNode;    // 1 byte, used later for tree gen
;         char character; // 1 byte
;         int frequency;  // 4 bytes
;     } frequencies[];
; }
;
; This procedure utilizes the following registers: rax for memory references, rsi for 
; string operations, rcx for loop counters, rbx for address calculations, and r15 as
; a temporary register for purposes such as acting as a buffer to transfer memory or
; passing arguments to the stack.
count proc
    push rbp
    mov rbp, rsp
     
    ; Allocate memory
    mov r15, 4096 ; 4096 bytes / 1 mem page
    push r15
    call mmap
    add rsp, 8

    ; Retrieve string argument
    mov rsi, [rbp + 16]

    ; Store zero for starting uniqueCharactersCount value
    mov dword ptr [rax], 0 
    
    ; Set loop counter to 0 
    xor rcx, rcx

; Loop through each letter in the string
_loop:
    mov dl, [rsi + rcx] ; Fetch current letter to process
    cmp dl, 0           ; Check if null character
    je _exit            ; If so, end loop

    push rcx            ; Save counter to prepare for inner loop
    xor rcx, rcx        ; Start count at zero

; Search if array has existing entry for this character 
_search_loop:
    cmp dword ptr [rax], ecx ; Check if reached end of array
    je _search_add       ; Jump to create new character entry

    ; Calculate memory address of character entry
    imul rbx, rcx, 6
    add rbx, rax 
    add rbx, 4

    cmp dl, byte ptr [rbx + 1] ; Check if characters are equal
    jne _search_continue   ; If not, move on to next character

    ; Found existing character entry, so add one to the frequency count
    mov r15d, dword ptr [rbx + 2]
    inc r15d 
    mov [rbx + 2], r15d 
    jmp _search_exit

_search_continue:
    inc ecx ; Move to next character entry
    jmp _search_loop

; Create new character entry
_search_add:
    ; Increase uniqueCharactersCount
    mov ebx, [rax]
    inc ebx
    mov [rax], dword ptr ebx

    ; Calculate memory address of character entry
    imul rbx, rcx, 6
    add rbx, rax 
    add rbx, 4

    ; Set character entry data
    mov byte ptr [rbx], 0
    mov [rbx + 1], dl
    mov dword ptr [rbx + 2], 1d

_search_exit:
    pop rcx ; Restore counter register for outer loop (characters loop)
    inc rcx ; Move to next character 
    jmp _loop

_exit:
    mov rsp, rbp
    pop rbp
    ret

count endp

; `sort` takes in a character frequency structure generated by `count` as a parameter through the rax register.
; It then performs insertion sort on the character frequency array. Charcters with a greater frequency and
; greater ascii value will be placed farther right.
;
; This procedure utilizes the following registers: rcx for loop counters, and r13, r14, and r15 for calculations and
; memory copying.
sort proc
    ; Set loop counter to 0 
    xor rcx, rcx

; Loop through each character entry
_loop:
    inc rcx ; Move to next character entry

    cmp ecx, dword ptr [rax] ; Check if reached end of character entries
    je _exit

    ; Calculate memory address of selected character entry
    imul r15, rcx, 6
    add r15, rax
    add r15, 4

    ; Retrieve frequency of selected character
    mov r13d, dword ptr [r15 + 2] 

    ; Save loop counter to prepare to enter inner loop
    push rcx

; Loop backwards from current character entry and search for optimal location
; placement of character entry where the character entry has a greater frequency
; than the character entry before and lower frequency than the character entry
; following. On the condition, the frequencies are equal, ascii value will be compared instead.
_search:
    dec rcx ; Move to previous character entry

    cmp rcx, -1 ; Check if reached start of character entries
    je _search_exit

    ; Calculate memory address of character entry
    imul r14, rcx, 6
    add r14, rax
    add r14, 4

    cmp r13d, dword ptr [r14 + 2] ; Check if selected has greater frequency 
    jg _search_exit           ; If so, end search

    cmp r13d, dword ptr [r14 + 2] ; Check if selected has unequal frequency
    jne _swap                 ; If so, swap

    mov r12b, byte ptr [r15 + 1]  ; Retrieve ascii value of selected
    cmp r12b, byte ptr [r14 + 1]  ; Check if selected has greater ascii value
    jg _search_exit           ; If so, end search

; Swap character entries at r14 and 15
_swap:
    ; Swap frequencies
    mov r12d, [r14 + 2]
    mov [r14 + 2], r13d
    mov [r15 + 2], r12d

    ; Swap characters
    mov r11b, [r15 + 1]
    mov r12b, [r14 + 1]
    mov [r14 + 1], r11b
    mov [r15 + 1], r12b

    mov r15, r14
    jmp _search

_search_exit:
    pop rcx ; Restore counter register for outer loop
    jmp _loop

_exit:
    ret

sort endp

; `tree` constructs a huffman tree based on a character frequnecy map passed in as a parameter through
; the rax register. Characters with greater frequency will have less depth in the tree so less bits are
; needed to reach the character. The tree is returned in the rax register.
;
; This procedure utilizes the following registers: rcx for loop counters, r11, r12, r13, and r14 for
; memory references, and r8, r9, r10, and r15 as temeporary registers for calculations.
tree proc
    mov r11, rax ; Store character frequency map location in r11

    ; Allocate space for leaves heap
    imul r15d, dword ptr [r11], 8
    push r15     ; Load space parameter onto stack
    call mmap
    mov r12, rax ; Store leaves heap location in r12
    add rsp, 8 ; Clear parameter off stack
    
    lea r15, [r11 + 4]
    xor rcx, rcx ; Set counter register to zero

; Populate leaves heap with character frequencies entry
_base:
    mov [r12 + rcx * 8], r15 ; Move memory address of leaf into heap

    ; Move to next leaf 
    add r15, 6
    inc rcx

    ; Check if reached end of character frequency map 
    cmp ecx, dword ptr [r11]
    jne _base 

    ; Check for only one leaf, if so no need to build tree
    cmp rcx, 1
    jle _exit

    call create_tree
    mov r13, rax

; Start constructing tree from the leaves
_construct:
    ; Create tree node with first two items in heap
    mov r15, [r12 + 8]
    push r15              ; Load right child argument with first item in heap
    mov r15, [r12]
    push r15              ; Load left child argument
    push r13              ; Load tree argument
    call tree_create_node
    add rsp, 24         ; Clear arguments off stack
    mov r14, rax          ; Store returning tree node in r14

    ; Retrieve tree node frequency
    push r14      ; Load tree node argument 
    call tree_node_get_freq
    mov r10d, eax ; Store returning frequency in r10d
    add rsp, 8  ; Clear arguments off stack

    add r12, 8   ; Remove first item in heap
    mov [r12], r14 ; Store new tree node in heap

    
    mov r8, r12 ; Address for sort index
    mov r9, 1
    dec rcx

    cmp rcx, 1
    je _exit

; Resort tree node into the heap
_insert:
    ; Retrieve frequency of next tree node
    mov rax, [r8 + 8]
    push rax
    call tree_node_get_freq
    add rsp, 8

    ; Compare current frequency and frequency of next tree node
    cmp eax, r10d
    jge _construct

    ; Swap current tree node and next tree node
    mov r15, [r8 + 8]
    mov [r8], r15 
    mov [r8 + 8], r14

    ; Move to next tree node
    add r8, 8
    inc r9

    ; Check if reached end of tree nodes
    cmp r9, rcx 
    jne _insert
    jmp _construct

_exit:
    mov rax, [r12]
    ret

tree endp

generate proc
    push rbp
    mov rbp, rsp

    ; Allocate space to build string
    push rax
    mov r15, 4096
    push r15
    call mmap
    mov r12, rax
    add rsp, 8
    pop rax

    xor r11, r11    ; Store string length (used allocated space)
    mov r10, 4096 ; Store max string length (total allocated space)

    ; Serialize tree
    call tree_serialize

    ; Encode string
    mov r15, [rbp + 16] ; Retrieve string argument
    push r15 
    call tree_encode_str
    add rsp, 8

    ; Set return values of string location and string length
    mov rax, r12 
    mov rcx, r11
    
    mov rsp, rbp
    pop rbp
    ret

generate endp

; HUFFMAN

print_line proc
    mov r15, 1
    push r15
    mov r15, newline
    push r15
    call print
    add rsp, 16
    ret

print_line endp

; TREE

; `create_tree` allocates memory for a tree structure and populates the fields.
; The head of the tree will initially be set to null.
; The memory layout for the tree structure will be:
;
; struct {
;     int usedMemory, allocatedMemory; // 8 bytes
;     struct {
;         bool isNode;        // 1 byte
;         void *left, *right; // 16 bytes
;         int frequency;      // 4 bytes
;     } *head;
;
;     struct {
;         bool isNode; 
;         void *left, *right; // 16 bytes
;     } nodes[];
; }
;
; The memory address of the tree is returned in the rax register.

create_tree proc
    ; Allocate memory
    mov r15, 4096 ; 4096 bytes / 1 mem page 
    push r15
    call mmap
    add rsp, 8

    mov dword ptr [rax], 22    ; Store used memory
    mov dword ptr [rax + 4], 4096  ; Store allocated memory
    ret

create_tree endp    
; `tree_create_node` allocates memory for a tree node structure and returns the memory
; address of the structure in the rax register. Calling this procedure requires a tree 
; structure created by `create_tree` and two tree nodes/leaves structures passed in as
; parameters through the stack.
; The memory layout for the tree node structure will be:
;
; struct {
;     bool isNode;        // 1 byte
;     void *left, *right; // 16 bytes
;     int frequency;      // 4 bytes
; }
;




tree_create_node proc
    push rbp
    mov rbp, rsp

    ; Load tree parameter from stack into register
    mov rax, [rbp + 16] 

    mov r15d, dword ptr [rax] ; Retrieve tree used memory
    add r15d, 21        ; Add 21 bytes (size of node) to tree used memory
    mov dword ptr [rax], r15d ; Update tree used memory

    cmp r15d, dword ptr [rax + 4] ; Check if tree has enough memory
    jge _enough_mem

    ; Save register to prepare for syscall
    push rax

    ; Load mem page location into parameters for mremap
    mov r15, rax 
    add r15, 4096 ; 4096 bytes / 1 mem page
    push r15

    ; Load alloc size into parameters for mremap
    mov r15, 4096 ; 4096 bytes / 1 mem page
    push r15

    call mremap
    add rsp, 16     ; Clear parameters off stack

    mov dword ptr [rax + 4], r15d

    ; Restore register after syscall
    pop rax

_enough_mem:
    ; Pinpoint memory location of node
    add eax, dword ptr [rax]
    sub eax, 21

    mov byte ptr [rax], 1 ; Store node signifier

    sub rsp, 8               ; Reserve space on stack to hold total frequency
    mov dword ptr [rbp - 8], 0 ; Store zero as initial total frequency of left and right node

    ; Handle left node parameter
    mov r15, [rbp + 24]      ; Retrieve left node parameter
    push rax                 ; Save rax for upcoming call 
    push r15                 ; Load into parameter for upcoming call
    call tree_node_get_freq  ; Retrieve frequency of left node 
    add dword ptr [rbp - 8], eax ; Add the left node frequency to total frequency
    add rsp, 8             ; Clear call parameters off stack
    pop rax                  ; Restore rax after call
    mov [rax + 1], r15       ; Store left node address in parent node

    ; Handle right node parameter
    mov r15, [rbp + 32]      ; Retrieve right node parameter
    push rax                 ; Save rax for upcoming call 
    push r15                 ; Load into parameter for upcoming call
    call tree_node_get_freq  ; Retrieve frequency of right node 
    add dword ptr [rbp - 8], eax ; Add the right node frequency to total frequency
    add rsp, 8             ; Clear call parameters off stack
    pop rax                  ; Restore rax after call
    mov [rax + 9], r15       ; Store right node address in parent node

    ; Store total frequnecy in node
    mov r15d, dword ptr [rbp - 8]
    mov [rax + 17], r15d

    ; Release space used to hold total frequency
    add rsp, 8

    mov rsp, rbp
    pop rbp
    ret

tree_create_node endp   

tree_node_get_freq proc
    push rbp
    mov rbp, rsp

    ; Load tree/node param
    mov rax, [rbp + 16]

    ; Check if node param is non null 
    cmp rax, 0
    je _freq_def

    ; Check if node param is a leaf
    cmp byte ptr [rax], 0
    jne _node_freq

    ; Get size of leaf
    mov eax, dword ptr [rax + 2]
    jmp _exit 

_node_freq:
    ; Check if node param is not a leaf
    cmp byte ptr [rax], 1
    jne _freq_def

    ; Get size of node
    mov eax, dword ptr [rax + 17]
    jmp _exit

_freq_def:
    mov rax, 0

_exit:
    mov rsp, rbp
    pop rbp
    ret
tree_node_get_freq endp

; TODO
tree_serialize proc
    ret
tree_serialize endp

; `tree_encode_char` is a recursive helper procedure for `tree_encode_str` that encodes a single character
; by traversing the huffman tree. The tree parameter are taken in through the stack while the character
; parameter is passed in through the r14 register.
; 
; This procedure returns a boolean in the rax register based on whether the character has been found or not
; in the tree.
tree_encode_char proc
    push rbp
    mov rbp, rsp

    ; Set default return value to false
    xor rax, rax
    
    ; Check if node is a leaf
    mov r15, [rbp + 16]
    cmp byte ptr [r15], 0
    je _is_leaf

    ; Check if string has enough memory before writing to it
    cmp r11, r10
    jl _enough_mem

    push rax ; Save register to prepare for syscall

    ; Allocate more memory
    mov r15, 4096d
    push r15
    push r10
    call mremap
    add rsp, 16 

    pop rax  ; Restore register after syscall

    ; Add 4096 bytes to total allocated bytes
    add r10, 4096

_enough_mem:
    ; If not a leaf...
    ; Handle left node
    mov byte ptr [r12 + r11], 48 ; Write 0 to string for left node
    inc r11              ; Increase string length

    ; Traverse left node
    mov r15, [rbp + 16]
    mov r15, [r15 + 1]
    push r15
    call tree_encode_char
    add rsp, 8

    ; Check if already found character in left node
    cmp rax, 1
    je _exit

    ; Handle right node
    mov byte ptr [r12 + r11 - 1], 49 ; Overwrite 0 with 1 since character was not found in left node

    ; Traverse right node
    mov r15, [rbp + 16] ; Retrieve node from parameter
    mov r15, [r15 + 9]  ; Retrieve right node of node
    push r15
    call tree_encode_char
    add rsp, 8

    cmp rax, 1
    je _exit 

    dec r11 ; Decrease string length in the case of character not found in this node
    jmp _exit

_is_leaf:
    mov r15, [rbp + 16]
    cmp byte ptr [r15 + 1], r14b
    jne _exit

    ; Set return value to true since found character
    mov rax, 1

_exit:
    mov rsp, rbp
    pop rbp
    ret
tree_encode_char endp

tree_encode_str proc
    push rbp
    mov rbp, rsp

    mov r13, rax        ; Retrieve tree parameter in r13
    mov rsi, [rbp + 16] ; Retrieve string parameter

    ; Clear counter register
    xor rcx, rcx

    ; Load the tree parameter for `tree_encode_char`
    push r13

; Loop through the string, character by character
_loop:
    mov r14b, byte ptr [rsi + rcx] ; Retrieve current character
    cmp r14b, 0              ; Check if reached end of string
    je _exit
     
    ; Encode character in r14b
    call tree_encode_char

    inc rcx ; Move to next character
    jmp _loop

_exit:
    add rsp, 8 ; Clear parameter off stack
    mov rax, r12 ; Place the returning string in rax

    mov rsp, rbp
    pop rbp
    ret
tree_encode_str endp


stackpush MACRO
    push rdi
    push rsi
    push rdx
    push r10
    push r8
    push r9 
    push r11
    push rcx
ENDM

stackpop MACRO
    pop rcx
    pop r11
    pop r9
    pop r8
    pop r10
    pop rdx
    pop rsi
    pop rdi
ENDM

; Call mmap
mmap proc
    push rbp
    mov rbp, rsp

    stackpush

    mov rax, sys_mmap
    xor rdi, rdi
    mov rsi, [rbp + 16] ; Retrieve size from arguments
    mov rdx, 33       ; READ and WRITE access
    mov r10, 4098    ; PRIVATE and ANON flag 
    mov r8, -1       ; No file backing
    xor r9, r9         ; No offset
    syscall

    stackpop

    mov rsp, rbp
    pop rbp
    ret

mmap endp

; Expand mmap
mremap proc
    push rbp
    mov rbp, rsp

    stackpush

    mov rax, sys_mmap
    mov rdi, [rbp + 16] ; Retrieve mem location from arguments
    mov rsi, [rbp + 24] ; Retrieve size from arguments
    mov rdx, 3        ; READ and WRITE access
    mov r10, 4098     ; PRIVATE and ANON flag 
    mov r8, -1        ; No file backing
    xor r9, r9          ; No offset
    syscall

    stackpop

    mov rsp, rbp
    pop rbp
    ret

mremap endp

; Print
print proc
    push rbp
    mov rbp, rsp

    stackpush

    mov rax, sys_write
    mov rdi, 1
    mov rsi, [rbp + 16]
    mov rdx, [rbp + 24]
    syscall

    stackpop

    mov rsp, rbp
    pop rbp
    ret
print endp

END